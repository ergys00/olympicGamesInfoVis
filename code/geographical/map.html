<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Olympic Data Dashboard</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            #dashboard {
                display: flex;
                justify-content: space-between; /* Allinea gli elementi sulla stessa riga */
                width: 100%;
                max-width: 1800px; /* Limita la larghezza massima del dashboard */
                margin: 0 auto; /* Centra il dashboard */
            }
            .chart-container {
                flex: 1; /* Fai in modo che i contenitori occupino lo spazio disponibile */
                margin: 10px;
                border: 1px solid #ccc;
                padding: 10px;
                background-color: #f9f9f9;
                border-radius: 8px;
                box-sizing: border-box; /* Include padding e border nelle dimensioni */
            }
            #map {
                flex: 2; /* La mappa occupa più spazio */
            }
            #barchart {
                flex: 1; /* Il bar chart occupa meno spazio */
            }
            .chart-title {
                text-align: center;
                font-weight: bold;
                margin-bottom: 10px;
            }
            svg {
                display: block;
                margin: auto;
                background: white;
            }
            .tooltip {
                position: absolute;
                background: lightgray;
                padding: 5px;
                border-radius: 5px;
                display: none;
                pointer-events: none;
            }
            #sports {
                display: block;
                margin: 10px auto;
                padding: 5px;
                width: 200px;
            }
            .back-button {
                position: absolute;
                bottom: 25px;
                left: 25px;
                padding: 8px 15px;
                background-color: #3498db;
                color: white;
                text-decoration: none;
                border-radius: 5px;
                font-size: 14px;
                z-index: 1000;
                transition: background-color 0.2s;
            }
            .back-button:hover {
                background-color: #2980b9;
            }
            .legend {
                font-size: 12px;
            }

            .legend rect {
                stroke: #333;
                stroke-width: 1;
            }

            .legend-label {
                font-size: 10px;
                fill: #333;
            }
        </style>
    </head>
    <body>
        <a href="../../index.html" class="back-button">← Back to Dashboard</a>
        <div id="dashboard">
            <div id="map" class="chart-container">
                <div class="chart-title">Geospatial Medal Distribution</div>
                <select id="sports"></select>
                <svg></svg>
            </div>
            <div id="barchart" class="chart-container">
                <div id="chart-title" class="chart-title"></div>
                <svg></svg>
            </div>
        </div>
        <div class="tooltip"></div>
    </body>
    <script>
        // Tooltip
        const tooltip = d3.select(".tooltip");
        let worldGeoJson; // Store the world GeoJSON data
        let olympicData; // Store the Olympic data
        let sportsSet; // Store list of the sports

        // Load both datasets
        Promise.all([
            d3.json("../../data/dataset.json"),
            d3.json(
                "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
            ),
        ]).then(([data, world]) => {
            olympicData = data;
            worldGeoJson = world;
            sportsSet = getSportsSet(data);
            // Initialize the select dropdown
            populateSelect(data);

            // Get initial data for All Sports (default)
            const geoData = transformGeoDataFilteredBySport(data, "All");

            // Create initial visualization
            createGeospatialVisualization(geoData);

            // Add event listener for sport selection
            document
                .getElementById("sports")
                .addEventListener("change", (event) => {
                    const selectedSport = event.target.value;
                    const newGeoData = transformGeoDataFilteredBySport(
                        olympicData,
                        selectedSport
                    );
                    updateVisualization(newGeoData);
                });
        });

        function getSportsSet(data) {
            sportsSet = new Set();
            // Extract unique sports
            data.links.forEach((link) => {
                if (link.source) sportsSet.add(link.source);
            });
            return sportsSet;
        }

        function createLegend(colorScale) {
            const legendWidth = 200; // Width of the legend
            const legendHeight = 20; // Height of the legend
            const margin = { top: 10, right: 10, bottom: 30, left: 10 };

            // Append the legend group to the map's SVG
            const legendSvg = d3
                .select("#map svg")
                .append("g")
                .attr("class", "legend")
                .attr(
                    "transform",
                    `translate(${margin.left},${
                        610 - legendHeight - margin.bottom
                    })`
                ); // Position at bottom-left

            // Create a gradient for the legend
            const gradient = legendSvg
                .append("defs")
                .append("linearGradient")
                .attr("id", "legend-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");

            // Add stops to the gradient
            const domain = colorScale.domain();
            const range = colorScale.range();
            gradient
                .selectAll("stop")
                .data(range)
                .enter()
                .append("stop")
                .attr("offset", (d, i) => i / (range.length - 1))
                .attr("stop-color", (d) => d);

            // Append the gradient rectangle
            legendSvg
                .append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#legend-gradient)")
                .attr("stroke", "#333")
                .attr("stroke-width", 1);

            // Add a scale for the legend
            const legendScale = d3
                .scaleLinear()
                .domain(domain)
                .range([0, legendWidth]);

            const legendAxis = d3.axisBottom(legendScale).ticks(5); // Adjust the number of ticks as needed

            legendSvg
                .append("g")
                .attr("transform", `translate(0,${legendHeight})`)
                .call(legendAxis)
                .selectAll(".tick text")
                .attr("class", "legend-label");
        }

        function updateLegend(colorScale) {
            const legendWidth = 200; // Width of the legend
            const legendHeight = 20; // Height of the legend
            const margin = { top: 10, right: 10, bottom: 30, left: 10 };

            // Remove the existing legend
            d3.select("#map svg .legend").remove();

            // Append the legend group to the map's SVG
            const legendSvg = d3
                .select("#map svg")
                .append("g")
                .attr("class", "legend")
                .attr(
                    "transform",
                    `translate(${margin.left},${
                        610 - legendHeight - margin.bottom
                    })`
                ); // Position at bottom-left

            // Create a gradient for the legend
            const gradient = legendSvg
                .append("defs")
                .append("linearGradient")
                .attr("id", "legend-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");

            // Add stops to the gradient
            const domain = colorScale.domain();
            const range = colorScale.range();
            gradient
                .selectAll("stop")
                .data(range)
                .enter()
                .append("stop")
                .attr("offset", (d, i) => i / (range.length - 1))
                .attr("stop-color", (d) => d);

            // Append the gradient rectangle
            legendSvg
                .append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#legend-gradient)")
                .attr("stroke", "#333")
                .attr("stroke-width", 1);

            // Add a scale for the legend
            const legendScale = d3
                .scaleLinear()
                .domain(domain)
                .range([0, legendWidth]);

            const legendAxis = d3.axisBottom(legendScale).ticks(5); // Adjust the number of ticks as needed

            legendSvg
                .append("g")
                .attr("transform", `translate(0,${legendHeight})`)
                .call(legendAxis)
                .selectAll(".tick text")
                .attr("class", "legend-label");
        }

        function populateSelect(data) {
            const selectElement = document.getElementById("sports");

            // Add 'All Sports' option
            const allOption = document.createElement("option");
            allOption.value = "All";
            allOption.textContent = "All Sports";
            allOption.selected = true;
            selectElement.appendChild(allOption);

            // Sort sports alphabetically
            const sortedSports = Array.from(sportsSet).sort();

            // Add options to select
            sortedSports.forEach((sport) => {
                const option = document.createElement("option");
                option.value = sport;
                option.textContent = sport;
                selectElement.appendChild(option);
            });
        }

        function transformGeoDataFilteredBySport(data, sport) {
            const geoMedals = {};
            data.links
                .filter((entry) =>
                    sport === "All" ? true : entry.source === sport
                )
                .forEach((link) => {
                    const target = link.target;
                    if (!geoMedals[target]) geoMedals[target] = 0;
                    geoMedals[target] += link.attr.length;
                });

            return data.nodes
                .filter((node) => node.noc)
                .map((node) => ({
                    name: node.name,
                    id: node.id,
                    totalMedals: geoMedals[node.id] || 0,
                }));
        }

        function createGeospatialVisualization(geoData) {
            const svgMap = d3
                .select("#map svg")
                .attr("width", 1200)
                .attr("height", 750)
                .attr("viewBox", [0, 0, 975, 610])
                .attr("style", "max-width: 100%; height: auto;");

            const projection = d3.geoMercator().center([0, 20]);
            const path = d3.geoPath().projection(projection);

            const mapGroup = svgMap.append("g");

            // Add zoom functionality with limited panning
            const zoom = d3
                .zoom()
                .scaleExtent([1, 8])
                .translateExtent([
                    [0, 0],
                    [975, 610],
                ])
                .on("zoom", (event) => {
                    mapGroup.attr("transform", event.transform);
                    updateLabels(event.transform.k);
                });

            svgMap.call(zoom);

            // Define color scale
            const colorScale = d3
                .scalePow()
                .domain([0, d3.max(geoData, (d) => d.totalMedals)])
                .range(["#fee5da", "#a4141c"])
                .exponent(0.5);

            createLegend(colorScale);
            // Draw the map
            const states = mapGroup
                .selectAll("path")
                .data(worldGeoJson.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("stroke", "white")
                .attr("stroke-width", "0.3")
                .attr("fill", (d) => {
                    const country = geoData.find((c) => {
                        if (c.name === d.properties.name) return true;
                        else if (c.id === d.id) return true;
                        else return false;
                    });
                    return country
                        ? colorScale(country.totalMedals)
                        : "#eeeeee";
                });

            // Update tooltip event listeners
            updateTooltipListeners(states, geoData);

            // Add labels for each country
            const labels = mapGroup
                .selectAll("text")
                .data(worldGeoJson.features)
                .enter()
                .append("text")
                .attr("x", (d) => {
                    const centroid = path.centroid(d);
                    return centroid[0];
                })
                .attr("y", (d) => {
                    const centroid = path.centroid(d);
                    return centroid[1];
                })
                .text((d) => {
                    if (isNaN(d.id)) return d.id;
                })
                .attr("fill", "black")
                .attr("text-anchor", "middle")
                .attr("pointer-events", "none")
                .style("font-size", 0)
                .style("opacity", 0);

            // Function to update labels based on zoom level
            function updateLabels(zoomLevel) {
                const labelBoxes = [];

                labels.each(function (d) {
                    const stateBbox = path.bounds(d);
                    const stateWidth = stateBbox[1][0] - stateBbox[0][0];
                    const stateHeight = stateBbox[1][1] - stateBbox[0][1];
                    const fontSize =
                        (Math.min(stateWidth, stateHeight) * 0.6) /
                        (0.9 * zoomLevel);
                    const clampedFontSize = Math.min(Math.max(fontSize, 1), 7);

                    if (clampedFontSize >= 1) {
                        const label = d3
                            .select(this)
                            .style("font-size", clampedFontSize + "px");

                        const bbox = this.getBBox();
                        let isOverlapping = false;
                        for (const box of labelBoxes) {
                            if (
                                bbox.x < box.x + box.width &&
                                bbox.x + bbox.width > box.x &&
                                bbox.y < box.y + box.height &&
                                bbox.y + bbox.height > box.y
                            ) {
                                isOverlapping = true;
                                break;
                            }
                        }

                        if (!isOverlapping) {
                            label.style("opacity", 1);
                            labelBoxes.push(bbox);
                        } else {
                            label.style("opacity", 0);
                        }
                    } else {
                        d3.select(this).style("opacity", 0);
                    }
                });
            }

            // Initialize labels at the default zoom level
            updateLabels(1);
        }

        function updateTooltipListeners(states, geoData) {
            states
                .on("mouseover", function (event, d) {
                    states.attr("opacity", 0.3);
                    d3.select(this).attr("opacity", 1);

                    const country = geoData.find((c) => {
                        if (c.name === d.properties.name) return true;
                        else if (c.id === d.id) return true;
                        else return false;
                    });
                    const medals = country ? country.totalMedals : 0;
                    tooltip
                        .style("display", "block")
                        .style("left", event.pageX + 10 + "px")
                        .style("top", event.pageY - 10 + "px")
                        .html(
                            `${d.properties.name}<br>Total Medals: ${medals}`
                        );
                })
                .on("mousemove", (event) => {
                    tooltip
                        .style("left", event.pageX + 10 + "px")
                        .style("top", event.pageY - 10 + "px");
                })
                .on("mouseout", function () {
                    states.attr("opacity", 1);
                    tooltip.style("display", "none");
                })
                .on("click", function (event, d) {
                    const countryId = d.id;
                    const countryName = d.properties.name;
                    document.getElementById("chart-title").innerHTML = "Sports Medals Leadership for " + d.properties.name
                    const sportsMedals = getSportsMedalsForCountry(
                        countryId,
                        countryName
                    );
                    drawBarChart(sportsMedals);
                });
        }

        function updateVisualization(newGeoData) {
            const colorScale = d3
                .scalePow()
                .domain([0, d3.max(newGeoData, (d) => d.totalMedals)])
                .range(["#fee5da", "#a4141c"])
                .exponent(0.5);

            const states = d3
                .select("#map svg")
                .selectAll("path")
                .data(worldGeoJson.features);

            states
                .transition()
                .duration(750)
                .attr("fill", (d) => {
                    const country = newGeoData.find((c) => c.id === d.id);
                    return country !== undefined && country.totalMedals !== 0
                        ? colorScale(country.totalMedals)
                        : "#eeeeee";
                });
            updateLegend(colorScale)

            // Update tooltip event listeners with the new data
            updateTooltipListeners(states, newGeoData);
        }

        function getSportsMedalsForCountry(countryId, countryName) {
            const sportsMedals = {};
            const realId = olympicData.nodes.find((c) => {
                if (c.name === countryName) return true;
                else if (c.id === countryId) return true;
            }).id;

            olympicData.links.forEach((link) => {
                if (link.target === realId) {
                    sportsSet.forEach((sport) => {
                        if (link.source === sport) {
                            if (!sportsMedals[sport]) {
                                sportsMedals[sport] = {
                                    male: 0,
                                    female: 0,
                                    total: 0,
                                };
                            }
                            link.attr.forEach((medal) => {
                                sportsMedals[sport].total += 1;
                                if (medal.athlete.sex === "Male") {
                                    sportsMedals[sport].male += 1;
                                } else if (medal.athlete.sex === "Female") {
                                    sportsMedals[sport].female += 1;
                                }
                            });
                        }
                    });
                }
            });

            return Object.entries(sportsMedals)
                .map(([sport, medals]) => ({
                    sport,
                    male: medals.male,
                    female: medals.female,
                    total: medals.total,
                }))
                .sort((a, b) => b.total - a.total);
        }

        function drawBarChart(data) {
            const svgBarChart = d3
                .select("#barchart svg")
                .attr("width", 600)
                .attr("height", 750)
                .attr("viewBox", [0, 0, 600, 750])
                .attr("style", "max-width: 100%; height: auto;");

            svgBarChart.selectAll("*").remove();

            const margin = { top: 20, right: 100, bottom: 40, left: 60 };
            const width = 600 - margin.left - margin.right;
            const height = 750 - margin.top - margin.bottom;

            // Prepare data for stacked bars
            const sports = data.map((d) => d.sport);
            const stackedData = d3.stack().keys(["female", "male"])(data);

            // X scale for sports
            const x = d3
                .scaleBand()
                .domain(sports)
                .range([margin.left, width + margin.left])
                .padding(0.1);

            // Y scale
            const y = d3
                .scaleLinear()
                .domain([0, d3.max(data, (d) => d.total)])
                .nice()
                .range([height + margin.top, margin.top]);

            // Color scale for gender
            const color = d3
                .scaleOrdinal()
                .domain(["female", "male"])
                .range(["#fce4dc", "#a0cce4"]);

            // Add stacked bars
            const layer = svgBarChart
                .selectAll("g.layer")
                .data(stackedData)
                .join("g")
                .attr("class", "layer")
                .attr("fill", (d) => color(d.key));

            layer
                .selectAll("rect")
                .data((d) => d)
                .join("rect")
                .attr("x", (d) => x(d.data.sport))
                .attr("y", (d) => y(d[1]))
                .attr("height", (d) => y(d[0]) - y(d[1]))
                .attr("width", x.bandwidth())
                .on("mouseover", function (event, d) {
                    const gender = d3.select(this.parentNode).datum().key;
                    const value = d[1] - d[0];
                    tooltip
                        .style("display", "block")
                        .style("left", event.pageX + 10 + "px")
                        .style("top", event.pageY - 10 + "px")
                        .html(
                            `${
                                gender.charAt(0).toUpperCase() + gender.slice(1)
                            }: ${value}`
                        );
                })
                .on("mouseout", function () {
                    tooltip.style("display", "none");
                });

            // Add total medals as text on top of each bar
            svgBarChart
                .selectAll(".total-label")
                .data(data)
                .join("text")
                .attr("class", "total-label")
                .attr("x", (d) => x(d.sport) + x.bandwidth() / 2)
                .attr("y", (d) => y(d.total) - 5)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text((d) => d.total);

            // Add axes
            svgBarChart
                .append("g")
                .attr("transform", `translate(0,${height + margin.top})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            svgBarChart
                .append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y));

            // Add legend
            const legend = svgBarChart
                .append("g")
                .attr("font-family", "sans-serif")
                .attr("font-size", 10)
                .attr("text-anchor", "start")
                .selectAll("g")
                .data(["female", "male"])
                .join("g")
                .attr(
                    "transform",
                    (d, i) =>
                        `translate(${width + margin.left + 10},${
                            margin.top + i * 20
                        })`
                );

            legend
                .append("rect")
                .attr("x", 0)
                .attr("width", 19)
                .attr("height", 19)
                .attr("fill", color);

            legend
                .append("text")
                .attr("x", 24)
                .attr("y", 9.5)
                .attr("dy", "0.32em")
                .text((d) => d.charAt(0).toUpperCase() + d.slice(1));
        }
    </script>
</html>
